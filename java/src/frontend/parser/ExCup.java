//----------------------------------------------------
// The following code was generated by CUP v0.11a beta 20060608
// Sat Aug 31 17:43:42 BST 2013
//----------------------------------------------------

package frontend.parser;

import frontend.tokeniser.Token;

/**
 * CUP v0.11a beta 20060608 generated parser.
 * 
 * @version Sat Aug 31 17:43:42 BST 2013
 */
public class ExCup extends java_cup.runtime.lr_parser {

  /** Default constructor. */
  public ExCup() {
    super();
  }

  /** Constructor which sets the default scanner. */
  public ExCup(final java_cup.runtime.Scanner s) {
    super(s);
  }

  /** Constructor which sets the default scanner. */
  public ExCup(final java_cup.runtime.Scanner s,
      final java_cup.runtime.SymbolFactory sf) {
    super(s, sf);
  }

  /** Production table. */
  protected static final short _production_table[][] = unpackFromStrings(new String[] { "\000\010\000\002\002\005\000\002\002\004\000\002\002"
      + "\005\000\002\002\003\000\002\003\005\000\002\003\005"
      + "\000\002\003\003\000\002\004\003" });

  /** Access to production table. */
  @Override
  public short[][] production_table() {
    return _production_table;
  }

  /** Parse-action table. */
  protected static final short[][] _action_table = unpackFromStrings(new String[] { "\000\016\000\004\010\004\001\002\000\014\002\ufffa\004"
      + "\ufffa\005\ufffa\006\ufffa\007\ufffa\001\002\000\014\002\ufffb"
      + "\004\ufffb\005\ufffb\006\ufffb\007\ufffb\001\002\000\014\002"
      + "\ufffe\004\ufffe\005\ufffe\006\014\007\015\001\002\000\010"
      + "\002\012\004\010\005\011\001\002\000\004\010\004\001"
      + "\002\000\004\010\004\001\002\000\004\002\000\001\002"
      + "\000\014\002\uffff\004\uffff\005\uffff\006\014\007\015\001"
      + "\002\000\004\010\004\001\002\000\004\010\004\001\002"
      + "\000\014\002\ufffd\004\ufffd\005\ufffd\006\ufffd\007\ufffd\001"
      + "\002\000\014\002\ufffc\004\ufffc\005\ufffc\006\ufffc\007\ufffc"
      + "\001\002\000\014\002\001\004\001\005\001\006\014\007" + "\015\001\002" });

  /** Access to parse-action table. */
  @Override
  public short[][] action_table() {
    return _action_table;
  }

  /** <code>reduce_goto</code> table. */
  protected static final short[][] _reduce_table = unpackFromStrings(new String[] { "\000\016\000\010\002\006\003\005\004\004\001\001\000"
      + "\002\001\001\000\002\001\001\000\002\001\001\000\002"
      + "\001\001\000\006\003\017\004\004\001\001\000\006\003"
      + "\012\004\004\001\001\000\002\001\001\000\002\001\001"
      + "\000\004\004\016\001\001\000\004\004\015\001\001\000"
      + "\002\001\001\000\002\001\001\000\002\001\001" });

  /** Access to <code>reduce_goto</code> table. */
  @Override
  public short[][] reduce_table() {
    return _reduce_table;
  }

  /** Instance of action encapsulation class. */
  protected CUP$ExCup$actions action_obj;

  /** Action encapsulation object initializer. */
  @Override
  protected void init_actions() {
    action_obj = new CUP$ExCup$actions(this);
  }

  /** Invoke a user supplied parse action. */
  @Override
  public java_cup.runtime.Symbol do_action(final int act_num,
      final java_cup.runtime.lr_parser parser, final java.util.Stack stack,
      final int top) throws java.lang.Exception {
    /* call code in generated class */
    return action_obj.CUP$ExCup$do_action(act_num, parser, stack, top);
  }

  /** Indicates id state. */
  @Override
  public int start_state() {
    return 0;
  }

  /** Indicates id production. */
  @Override
  public int start_production() {
    return 1;
  }

  /** <code>EOF</code> Symbol index. */
  @Override
  public int EOF_sym() {
    return 0;
  }

  /** <code>error</code> Symbol index. */
  @Override
  public int error_sym() {
    return 1;
  }

}

/** Cup generated class to encapsulate user supplied action code. */
class CUP$ExCup$actions {
  private final ExCup parser;

  /** Constructor */
  CUP$ExCup$actions(final ExCup parser) {
    this.parser = parser;
  }

  /** Method with the actual generated action code. */
  public final java_cup.runtime.Symbol CUP$ExCup$do_action(
      final int CUP$ExCup$act_num,
      final java_cup.runtime.lr_parser CUP$ExCup$parser,
      final java.util.Stack CUP$ExCup$stack, final int CUP$ExCup$top)
      throws java.lang.Exception {
    /* Symbol object for return from actions */
    java_cup.runtime.Symbol CUP$ExCup$result;

    /* select the action based on the action number */
    switch (CUP$ExCup$act_num) {
    /* . . . . . . . . . . . . . . . . . . . . */
    case 7: // factor ::= INTEGER_LITERAL
    {
      Node RESULT = null;
      final int ileft = ((java_cup.runtime.Symbol) CUP$ExCup$stack.peek()).left;
      final int iright = ((java_cup.runtime.Symbol) CUP$ExCup$stack.peek()).right;
      final Token i = (Token) ((java_cup.runtime.Symbol) CUP$ExCup$stack.peek()).value;
      RESULT = new Node(new Token(i.val, i.id));
      CUP$ExCup$result = parser.getSymbolFactory().newSymbol("factor", 2,
          ((java_cup.runtime.Symbol) CUP$ExCup$stack.peek()),
          ((java_cup.runtime.Symbol) CUP$ExCup$stack.peek()), RESULT);
    }
      return CUP$ExCup$result;

      /* . . . . . . . . . . . . . . . . . . . . */
    case 6: // term ::= factor
    {
      Node RESULT = null;
      final int fleft = ((java_cup.runtime.Symbol) CUP$ExCup$stack.peek()).left;
      final int fright = ((java_cup.runtime.Symbol) CUP$ExCup$stack.peek()).right;
      final Node f = (Node) ((java_cup.runtime.Symbol) CUP$ExCup$stack.peek()).value;
      RESULT = f;
      CUP$ExCup$result = parser.getSymbolFactory().newSymbol("term", 1,
          ((java_cup.runtime.Symbol) CUP$ExCup$stack.peek()),
          ((java_cup.runtime.Symbol) CUP$ExCup$stack.peek()), RESULT);
    }
      return CUP$ExCup$result;

      /* . . . . . . . . . . . . . . . . . . . . */
    case 5: // term ::= term DIVIDE factor
    {
      Node RESULT = null;
      final int tleft = ((java_cup.runtime.Symbol) CUP$ExCup$stack
          .elementAt(CUP$ExCup$top - 2)).left;
      final int tright = ((java_cup.runtime.Symbol) CUP$ExCup$stack
          .elementAt(CUP$ExCup$top - 2)).right;
      final Node t = (Node) ((java_cup.runtime.Symbol) CUP$ExCup$stack
          .elementAt(CUP$ExCup$top - 2)).value;
      final int divideleft = ((java_cup.runtime.Symbol) CUP$ExCup$stack
          .elementAt(CUP$ExCup$top - 1)).left;
      final int divideright = ((java_cup.runtime.Symbol) CUP$ExCup$stack
          .elementAt(CUP$ExCup$top - 1)).right;
      final Token divide = (Token) ((java_cup.runtime.Symbol) CUP$ExCup$stack
          .elementAt(CUP$ExCup$top - 1)).value;
      final int fleft = ((java_cup.runtime.Symbol) CUP$ExCup$stack.peek()).left;
      final int fright = ((java_cup.runtime.Symbol) CUP$ExCup$stack.peek()).right;
      final Node f = (Node) ((java_cup.runtime.Symbol) CUP$ExCup$stack.peek()).value;
      RESULT = new Node(new Token(divide.val, divide.id), t, f);
      CUP$ExCup$result = parser.getSymbolFactory().newSymbol(
          "term",
          1,
          ((java_cup.runtime.Symbol) CUP$ExCup$stack
              .elementAt(CUP$ExCup$top - 2)),
          ((java_cup.runtime.Symbol) CUP$ExCup$stack.peek()), RESULT);
    }
      return CUP$ExCup$result;

      /* . . . . . . . . . . . . . . . . . . . . */
    case 4: // term ::= term TIMES factor
    {
      Node RESULT = null;
      final int tleft = ((java_cup.runtime.Symbol) CUP$ExCup$stack
          .elementAt(CUP$ExCup$top - 2)).left;
      final int tright = ((java_cup.runtime.Symbol) CUP$ExCup$stack
          .elementAt(CUP$ExCup$top - 2)).right;
      final Node t = (Node) ((java_cup.runtime.Symbol) CUP$ExCup$stack
          .elementAt(CUP$ExCup$top - 2)).value;
      final int timesleft = ((java_cup.runtime.Symbol) CUP$ExCup$stack
          .elementAt(CUP$ExCup$top - 1)).left;
      final int timesright = ((java_cup.runtime.Symbol) CUP$ExCup$stack
          .elementAt(CUP$ExCup$top - 1)).right;
      final Token times = (Token) ((java_cup.runtime.Symbol) CUP$ExCup$stack
          .elementAt(CUP$ExCup$top - 1)).value;
      final int fleft = ((java_cup.runtime.Symbol) CUP$ExCup$stack.peek()).left;
      final int fright = ((java_cup.runtime.Symbol) CUP$ExCup$stack.peek()).right;
      final Node f = (Node) ((java_cup.runtime.Symbol) CUP$ExCup$stack.peek()).value;
      RESULT = new Node(new Token(times.val, times.id), t, f);
      CUP$ExCup$result = parser.getSymbolFactory().newSymbol(
          "term",
          1,
          ((java_cup.runtime.Symbol) CUP$ExCup$stack
              .elementAt(CUP$ExCup$top - 2)),
          ((java_cup.runtime.Symbol) CUP$ExCup$stack.peek()), RESULT);
    }
      return CUP$ExCup$result;

      /* . . . . . . . . . . . . . . . . . . . . */
    case 3: // expr ::= term
    {
      Node RESULT = null;
      final int tleft = ((java_cup.runtime.Symbol) CUP$ExCup$stack.peek()).left;
      final int tright = ((java_cup.runtime.Symbol) CUP$ExCup$stack.peek()).right;
      final Node t = (Node) ((java_cup.runtime.Symbol) CUP$ExCup$stack.peek()).value;
      RESULT = t;
      CUP$ExCup$result = parser.getSymbolFactory().newSymbol("expr", 0,
          ((java_cup.runtime.Symbol) CUP$ExCup$stack.peek()),
          ((java_cup.runtime.Symbol) CUP$ExCup$stack.peek()), RESULT);
    }
      return CUP$ExCup$result;

      /* . . . . . . . . . . . . . . . . . . . . */
    case 2: // expr ::= expr MINUS term
    {
      Node RESULT = null;
      final int eleft = ((java_cup.runtime.Symbol) CUP$ExCup$stack
          .elementAt(CUP$ExCup$top - 2)).left;
      final int eright = ((java_cup.runtime.Symbol) CUP$ExCup$stack
          .elementAt(CUP$ExCup$top - 2)).right;
      final Node e = (Node) ((java_cup.runtime.Symbol) CUP$ExCup$stack
          .elementAt(CUP$ExCup$top - 2)).value;
      final int minusleft = ((java_cup.runtime.Symbol) CUP$ExCup$stack
          .elementAt(CUP$ExCup$top - 1)).left;
      final int minusright = ((java_cup.runtime.Symbol) CUP$ExCup$stack
          .elementAt(CUP$ExCup$top - 1)).right;
      final Token minus = (Token) ((java_cup.runtime.Symbol) CUP$ExCup$stack
          .elementAt(CUP$ExCup$top - 1)).value;
      final int tleft = ((java_cup.runtime.Symbol) CUP$ExCup$stack.peek()).left;
      final int tright = ((java_cup.runtime.Symbol) CUP$ExCup$stack.peek()).right;
      final Node t = (Node) ((java_cup.runtime.Symbol) CUP$ExCup$stack.peek()).value;
      RESULT = new Node(new Token(minus.val, minus.id), e, t);
      CUP$ExCup$result = parser.getSymbolFactory().newSymbol(
          "expr",
          0,
          ((java_cup.runtime.Symbol) CUP$ExCup$stack
              .elementAt(CUP$ExCup$top - 2)),
          ((java_cup.runtime.Symbol) CUP$ExCup$stack.peek()), RESULT);
    }
      return CUP$ExCup$result;

      /* . . . . . . . . . . . . . . . . . . . . */
    case 1: // $START ::= expr EOF
    {
      Object RESULT = null;
      final int start_valleft = ((java_cup.runtime.Symbol) CUP$ExCup$stack
          .elementAt(CUP$ExCup$top - 1)).left;
      final int start_valright = ((java_cup.runtime.Symbol) CUP$ExCup$stack
          .elementAt(CUP$ExCup$top - 1)).right;
      final Node start_val = (Node) ((java_cup.runtime.Symbol) CUP$ExCup$stack
          .elementAt(CUP$ExCup$top - 1)).value;
      RESULT = start_val;
      CUP$ExCup$result = parser.getSymbolFactory().newSymbol(
          "$START",
          0,
          ((java_cup.runtime.Symbol) CUP$ExCup$stack
              .elementAt(CUP$ExCup$top - 1)),
          ((java_cup.runtime.Symbol) CUP$ExCup$stack.peek()), RESULT);
    }
      /* ACCEPT */
      CUP$ExCup$parser.done_parsing();
      return CUP$ExCup$result;

      /* . . . . . . . . . . . . . . . . . . . . */
    case 0: // expr ::= expr PLUS term
    {
      Node RESULT = null;
      final int eleft = ((java_cup.runtime.Symbol) CUP$ExCup$stack
          .elementAt(CUP$ExCup$top - 2)).left;
      final int eright = ((java_cup.runtime.Symbol) CUP$ExCup$stack
          .elementAt(CUP$ExCup$top - 2)).right;
      final Node e = (Node) ((java_cup.runtime.Symbol) CUP$ExCup$stack
          .elementAt(CUP$ExCup$top - 2)).value;
      final int plusleft = ((java_cup.runtime.Symbol) CUP$ExCup$stack
          .elementAt(CUP$ExCup$top - 1)).left;
      final int plusright = ((java_cup.runtime.Symbol) CUP$ExCup$stack
          .elementAt(CUP$ExCup$top - 1)).right;
      final Token plus = (Token) ((java_cup.runtime.Symbol) CUP$ExCup$stack
          .elementAt(CUP$ExCup$top - 1)).value;
      final int tleft = ((java_cup.runtime.Symbol) CUP$ExCup$stack.peek()).left;
      final int tright = ((java_cup.runtime.Symbol) CUP$ExCup$stack.peek()).right;
      final Node t = (Node) ((java_cup.runtime.Symbol) CUP$ExCup$stack.peek()).value;
      RESULT = new Node(new Token(plus.val, plus.id), e, t);
      CUP$ExCup$result = parser.getSymbolFactory().newSymbol(
          "expr",
          0,
          ((java_cup.runtime.Symbol) CUP$ExCup$stack
              .elementAt(CUP$ExCup$top - 2)),
          ((java_cup.runtime.Symbol) CUP$ExCup$stack.peek()), RESULT);
    }
      return CUP$ExCup$result;

      /* . . . . . . */
    default:
      throw new Exception("Invalid action number found in internal parse table");

    }
  }
}
